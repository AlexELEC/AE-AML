From 2ae91258548c3682ad5df16ee22bdf28d9769bfe Mon Sep 17 00:00:00 2001
From: vpeter4 <peter.vicman@gmail.com>
Date: Mon, 29 Jun 2015 17:08:17 +0200
Subject: [PATCH 01/11] ts_uinput_touch: daemon translates tslib events to
 uinput

On one side it gets events from touchscreen using tslib library. On the other end it creates one new virtual device using uinput kernel module that allows to handle the input subsystem from user land. Inside application data from tslib is translated to uinput events. For now only ABS_X, ABS_Y, ABS_PRESSURE and BTN_TOUCH. It behaves in a similar way than touchpad. Short tap sends button press event and long slide sends only xy coordinates. Currently using it in OpenELEC distribution and Kodi application.

I think something like this was proposed in TODO.

Also ST1232 raw input plugin is included for "st1232-touchscreen" (found on 7" display for Udoo board with i.MX6 SoC).
---
 configure.ac            |   1 +
 plugins/Makefile.am     |  13 +-
 plugins/plugins.h       |   1 +
 plugins/st1232-raw.c    | 303 +++++++++++++++++++++++
 src/Makefile.am         |   4 +
 src/ts_load_module.c    |   3 +
 tests/Makefile.am       |   5 +-
 tests/testutils.c       |   7 +
 tests/ts_calibrate.c    |   4 +
 tests/ts_uinput_touch.c | 624 ++++++++++++++++++++++++++++++++++++++++++++++++
 10 files changed, 963 insertions(+), 2 deletions(-)
 create mode 100644 plugins/st1232-raw.c
 create mode 100644 tests/ts_uinput_touch.c

diff --git a/configure.ac b/configure.ac
index dfdf269..6984002 100644
--- a/configure.ac
+++ b/configure.ac
@@ -69,6 +69,7 @@ TSLIB_CHECK_MODULE([dmc], [yes], [Enable building of dmc raw module (HP iPaq DMC
 TSLIB_CHECK_MODULE([input], [yes], [Enable building of generic input raw module (Linux /dev/input/eventN support)])
 TSLIB_CHECK_MODULE([touchkit], [yes], [Enable building of serial TouchKit raw module (Linux /dev/ttySX support)])
 TSLIB_CHECK_MODULE([galax], [yes], [Enable building of HID USB eGalax raw module (Linux /dev/hiddevN support)])
+TSLIB_CHECK_MODULE([st1232], [yes], [Enable building of ST1232 raw module (Linux /dev/input/eventN support)])
 
 
 
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index e938e17..e8e89e0 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -121,6 +121,12 @@ else
 CY8MRLN_PALMPRE_MODULE =
 endif
 
+if ENABLE_ST1232_MODULE
+ST1232_MODULE = st1232.la
+else
+ST1232_MODULE =
+endif
+
 pluginexec_LTLIBRARIES = \
 	$(LINEAR_MODULE) \
 	$(DEJITTER_MODULE) \
@@ -138,7 +144,8 @@ pluginexec_LTLIBRARIES = \
 	$(INPUT_MODULE) \
 	$(GALAX_MODULE) \
 	$(TOUCHKIT_MODULE) \
-	$(CY8MRLN_PALMPRE_MODULE)
+	$(CY8MRLN_PALMPRE_MODULE) \
+	$(ST1232_MODULE)
   
 variance_la_SOURCES	= variance.c
 variance_la_LDFLAGS	= -module $(LTVSN)
@@ -197,3 +204,7 @@ linear_h2200_la_LDFLAGS	= -module $(LTVSN)
 
 cy8mrln_palmpre_la_SOURCES = cy8mrln-palmpre.c
 cy8mrln_palmpre_la_LDFLAGS = -module $(LTVSN)
+
+st1232_la_SOURCES = st1232-raw.c
+st1232_la_LDFLAGS = -module $(LTVSN)
+st1232_la_LIBADD = $(top_builddir)/src/libts.la
diff --git a/plugins/plugins.h b/plugins/plugins.h
index 873aba5..d78877e 100644
--- a/plugins/plugins.h
+++ b/plugins/plugins.h
@@ -16,3 +16,4 @@ TSLIB_DECLARE_MODULE(arctic2);
 TSLIB_DECLARE_MODULE(tatung);
 TSLIB_DECLARE_MODULE(input);
 TSLIB_DECLARE_MODULE(cy8mrln_palmpre);
+TSLIB_DECLARE_MODULE(st1232);
diff --git a/plugins/st1232-raw.c b/plugins/st1232-raw.c
new file mode 100644
index 0000000..f05d21d
--- /dev/null
+++ b/plugins/st1232-raw.c
@@ -0,0 +1,303 @@
+/*
+ *  tslib/plugins/st1232-raw.c
+ *
+ * based on input-raw.c
+ * 2015.06 Peter Vicman
+ *
+ *  Original version:
+ *  Copyright (C) 2001 Russell King.
+ *
+ *  Rewritten for the Linux input device API:
+ *  Copyright (C) 2002 Nicolas Pitre
+ *
+ * This file is placed under the LGPL.  Please see the file
+ * COPYING for more details.
+ *
+ *
+ * Plugin for "st1232-touchscreen" (found on 7" display for Udoo board with i.MX6 SoC)
+ *
+ * Read raw x, y, and timestamp from a touchscreen device.
+ * Only first mt report is taken and send upstream.
+ * ST1232 driver doesn't report ABS_X/Y events - only MT - and
+ * doesn't report BTN_TOUCH event.
+ *
+ * In memory of my mom and dad ...
+ */
+#include "config.h"
+
+#include <errno.h>
+#include <stdio.h>
+#include <limits.h>
+
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include <linux/input.h>
+#ifndef EV_SYN /* 2.4 kernel headers */
+# define EV_SYN 0x00
+#endif
+#ifndef EV_CNT
+# define EV_CNT (EV_MAX+1)
+#endif
+#ifndef ABS_CNT
+# define ABS_CNT (ABS_MAX+1)
+#endif
+#ifndef KEY_CNT
+# define KEY_CNT (KEY_MAX+1)
+#endif
+
+#ifndef ABS_MT_POSITION_X
+# define ABS_MT_POSITION_X       0x35    /* Center X ellipse position */
+# define ABS_MT_POSITION_Y       0x36    /* Center Y ellipse position */
+#endif
+
+#define SYN_MT_REPORT		2
+
+#include "tslib-private.h"
+
+#define GRAB_EVENTS_WANTED	1
+#define GRAB_EVENTS_ACTIVE	2
+
+struct tslib_input {
+	struct tslib_module_info module;
+
+	int	current_x;
+	int	current_y;
+	int	current_p;
+
+	int	sane_fd;
+	int	using_syn;
+	int	grab_events;
+	int invert_y;
+};
+
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#define BIT(nr)                 (1UL << (nr))
+#define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+#define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+#define BITS_PER_BYTE           8
+#define BITS_PER_LONG           (sizeof(long) * BITS_PER_BYTE)
+#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+
+static int check_fd(struct tslib_input *i)
+{
+	struct tsdev *ts = i->module.dev;
+	int version;
+	long evbit[BITS_TO_LONGS(EV_CNT)];
+	long absbit[BITS_TO_LONGS(ABS_CNT)];
+
+	if (ioctl(ts->fd, EVIOCGVERSION, &version) < 0) {
+		fprintf(stderr, "tslib: Selected device is not a Linux input event device\n");
+		return -1;
+	}
+
+	if (version < EV_VERSION) {
+		fprintf(stderr, "tslib: Selected device uses a different version of the event protocol than tslib was compiled for\n");
+		return -1;
+	}
+
+	if ( (ioctl(ts->fd, EVIOCGBIT(0, sizeof(evbit)), evbit) < 0) ||
+		!(evbit[BIT_WORD(EV_ABS)] & BIT_MASK(EV_ABS)) ||
+		!(evbit[BIT_WORD(EV_KEY)] & BIT_MASK(EV_KEY)) ) {
+		fprintf(stderr, "tslib: Selected device is not a touchscreen (must support ABS and KEY event types)\n");
+		return -1;
+	}
+
+	if ((ioctl(ts->fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit)) < 0 ||
+		!(absbit[BIT_WORD(ABS_MT_POSITION_X)] & BIT_MASK(ABS_MT_POSITION_X)) ||
+		!(absbit[BIT_WORD(ABS_MT_POSITION_Y)] & BIT_MASK(ABS_MT_POSITION_Y))) {
+		fprintf(stderr, "tslib: Selected device is not a touchscreen (must support ABS_MT_POSITION_X and ABS_MT_POSITION_Y events)\n");
+		return -1;
+	}
+
+	if (evbit[BIT_WORD(EV_SYN)] & BIT_MASK(EV_SYN))
+		i->using_syn = 1;
+
+	if (i->grab_events == GRAB_EVENTS_WANTED) {
+		if (ioctl(ts->fd, EVIOCGRAB, (void *)1)) {
+			fprintf(stderr, "tslib: Unable to grab selected input device\n");
+			return -1;
+		}
+		i->grab_events = GRAB_EVENTS_ACTIVE;
+	}
+
+	return 0;
+}
+
+static int ts_st1232_read(struct tslib_module_info *inf,
+			 struct ts_sample *samp, int nr)
+{
+	struct tslib_input *i = (struct tslib_input *)inf;
+	struct tsdev *ts = inf->dev;
+	struct input_event ev;
+	int ret = nr;
+	int total = 0;
+	int mt_cnt = 0;		/* data for first finger */
+
+	if (i->sane_fd == -1)
+		i->sane_fd = check_fd(i);
+
+	if (i->sane_fd == -1)
+		return 0;
+
+	if (i->using_syn) {
+		while (total < nr) {
+			ret = read(ts->fd, &ev, sizeof(struct input_event));
+			if (ret < (int) sizeof(struct input_event)) {
+				total = -1;
+				break;
+			}
+
+			switch (ev.type) {
+				case EV_SYN:
+					if (ev.code == SYN_MT_REPORT) {
+						mt_cnt++;		/* data for next finger will come */
+					} else if (ev.code == SYN_REPORT) {
+						/* fill out a new complete event */
+						/* always send coordinate (last one on finger released) */
+						samp->x = i->current_x;
+						samp->y = i->current_y;
+						samp->pressure = i->current_p;	/* is 0 on finger released */
+						samp->tv = ev.time;
+      	
+						i->current_p = 0;		/* will be set again when getting xy cordinate */					
+						samp++;
+						total++;
+						mt_cnt = 0;
+					}
+					break;
+				case EV_ABS:
+					if (mt_cnt > 0)
+						break;	/* save data only for first finger */
+								
+					switch (ev.code) {
+						case ABS_MT_POSITION_X:					
+							i->current_x = ev.value;
+							i->current_p = 255;  /* touched */
+							break;
+						case ABS_MT_POSITION_Y:
+							i->current_y = ev.value;
+							i->current_p = 255;  /* touched */
+      	
+							if (i->invert_y > 0)
+								i->current_y = i->invert_y - i->current_y;
+							break;
+					}
+					break;
+			}
+		}
+		
+		ret = total;
+	} else {
+		fprintf(stderr, "tslib: st1232 and not using syn\n");
+		sleep(1);
+	}
+
+	return ret;
+}
+
+static int ts_st1232_fini(struct tslib_module_info *inf)
+{
+	struct tslib_input *i = (struct tslib_input *)inf;
+	struct tsdev *ts = inf->dev;
+
+	if (i->grab_events == GRAB_EVENTS_ACTIVE) {
+		if (ioctl(ts->fd, EVIOCGRAB, (void *)0)) {
+			fprintf(stderr, "tslib: Unable to un-grab selected input device\n");
+		}
+	}
+
+	free(inf);
+	return 0;
+}
+
+static const struct tslib_ops __ts_st1232_ops = {
+	.read	= ts_st1232_read,
+	.fini	= ts_st1232_fini,
+};
+
+static int parse_raw_grab(struct tslib_module_info *inf, char *str, void *data)
+{
+	struct tslib_input *i = (struct tslib_input *)inf;
+	unsigned long v;
+	int err = errno;
+
+	v = strtoul(str, NULL, 0);
+
+	if (v == ULONG_MAX && errno == ERANGE)
+		return -1;
+
+	errno = err;
+	switch ((int)data) {
+		case 1:
+			if (v)
+				i->grab_events = GRAB_EVENTS_WANTED;
+			break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+static int parse_invert_y(struct tslib_module_info *inf, char *str, void *data)
+{
+	struct tslib_input *i = (struct tslib_input *)inf;
+	int v;
+	int err = errno;
+
+	v = atoi(str);
+
+	if (v < 0)
+		return -1;
+
+	errno = err;
+	switch ((int)data) {
+		case 1:
+			i->invert_y = v;
+			break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+static const struct tslib_vars raw_vars[] =
+{
+	{ "grab_events", (void *)1, parse_raw_grab },
+	{ "invert_y", (void *)1, parse_invert_y },
+};
+
+#define NR_VARS (sizeof(raw_vars) / sizeof(raw_vars[0]))
+
+TSAPI struct tslib_module_info *st1232_mod_init(struct tsdev *dev, const char *params)
+{
+	struct tslib_input *i;
+
+	i = malloc(sizeof(struct tslib_input));
+	if (i == NULL)
+		return NULL;
+
+	i->module.ops = &__ts_st1232_ops;
+	i->current_x = 0;
+	i->current_y = 0;
+	i->current_p = 0;
+	i->sane_fd = -1;
+	i->using_syn = 0;
+	i->grab_events = 0;
+	i->invert_y = 0;
+
+	if (tslib_parse_vars(&i->module, raw_vars, NR_VARS, params)) {
+		free(i);
+		return NULL;
+	}
+
+	return &(i->module);
+}
+
+#ifndef TSLIB_STATIC_ST1232_MODULE
+	TSLIB_MODULE_INIT(st1232_mod_init);
+#endif
diff --git a/src/Makefile.am b/src/Makefile.am
index 5278d82..b561aa8 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -71,6 +71,10 @@ if ENABLE_STATIC_INPUT_MODULE
 libts_la_SOURCES += $(top_srcdir)/plugins/input-raw.c
 endif
 
+if ENABLE_STATIC_ST1232_MODULE
+libts_la_SOURCES += $(top_srcdir)/plugins/st1232-raw.c
+endif
+
 libts_la_LDFLAGS = -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
 		   -release $(LT_RELEASE) -export-dynamic
 libts_la_LIBADD  = -ldl
diff --git a/src/ts_load_module.c b/src/ts_load_module.c
index 00486be..886ca0a 100644
--- a/src/ts_load_module.c
+++ b/src/ts_load_module.c
@@ -73,6 +73,9 @@ static const struct {
 #ifdef TSLIB_STATIC_VARIANCE_MODULE
 	{ "variance", variance_mod_init },
 #endif
+#ifdef TSLIB_STATIC_ST1232_MODULE
+	{ "st1232", st1232_mod_init },
+#endif
 };
 
 #define countof(arr) (sizeof(arr) / sizeof((arr)[0]))
diff --git a/tests/Makefile.am b/tests/Makefile.am
index b76522d..2e80c18 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -11,7 +11,7 @@
 AM_CFLAGS               = -DTS_POINTERCAL=\"@TS_POINTERCAL@\" $(DEBUGFLAGS)
 INCLUDES		= -I$(top_srcdir)/src
 
-bin_PROGRAMS		= ts_test ts_calibrate ts_print ts_print_raw ts_harvest
+bin_PROGRAMS		= ts_test ts_calibrate ts_print ts_print_raw ts_harvest ts_uinput_touch
 
 ts_test_SOURCES		= ts_test.c fbutils.c fbutils.h font_8x8.c font_8x16.c font.h
 ts_test_LDADD		= $(top_builddir)/src/libts.la
@@ -27,3 +27,6 @@ ts_calibrate_LDADD	= $(top_builddir)/src/libts.la
 
 ts_harvest_SOURCES	= ts_harvest.c fbutils.c fbutils.h testutils.c testutils.h font_8x8.c font_8x16.c font.h
 ts_harvest_LDADD		= $(top_builddir)/src/libts.la
+
+ts_uinput_touch_SOURCES	= ts_uinput_touch.c testutils.c testutils.h
+ts_uinput_touch_LDADD		= $(top_builddir)/src/libts.la
diff --git a/tests/testutils.c b/tests/testutils.c
index dbd5b41..bc3756f 100644
--- a/tests/testutils.c
+++ b/tests/testutils.c
@@ -15,6 +15,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <errno.h>
 #include <sys/time.h>
 #include "tslib.h"
 #include "fbutils.h"
@@ -37,6 +38,9 @@ void getxy(struct tsdev *ts, int *x, int *y)
 
 	do {
 		if (ts_read_raw(ts, &samp[0], 1) < 0) {
+			if (errno == EINTR)
+				return;
+
 			perror("ts_read");
 			close_framebuffer ();
 			exit(1);
@@ -50,6 +54,9 @@ void getxy(struct tsdev *ts, int *x, int *y)
 		if (index < MAX_SAMPLES-1)
 			index++;
 		if (ts_read_raw(ts, &samp[index], 1) < 0) {
+			if (errno == EINTR)
+				return;
+
 			perror("ts_read");
 			close_framebuffer ();
 			exit(1);
diff --git a/tests/ts_calibrate.c b/tests/ts_calibrate.c
index eb0aca3..522fa7c 100644
--- a/tests/ts_calibrate.c
+++ b/tests/ts_calibrate.c
@@ -237,12 +237,16 @@ int main()
 
 	get_sample (ts, &cal, 0, 50,        50,        "Top left");
 	clearbuf(ts);
+	usleep(500000);
 	get_sample (ts, &cal, 1, xres - 50, 50,        "Top right");
 	clearbuf(ts);
+	usleep(500000);
 	get_sample (ts, &cal, 2, xres - 50, yres - 50, "Bot right");
 	clearbuf(ts);
+	usleep(500000);
 	get_sample (ts, &cal, 3, 50,        yres - 50, "Bot left");
 	clearbuf(ts);
+	usleep(500000);
 	get_sample (ts, &cal, 4, xres / 2,  yres / 2,  "Center");
 
 	if (perform_calibration (&cal)) {
diff --git a/tests/ts_uinput_touch.c b/tests/ts_uinput_touch.c
new file mode 100644
index 0000000..60efc46
--- /dev/null
+++ b/tests/ts_uinput_touch.c
@@ -0,0 +1,624 @@
+/*
+ *  tslib/src/ts_uinput_touch.c
+ *
+ *  Copyright (C) 2001 Russell King.
+ *  Copyright (C) 2015 Peter Vicman.
+ *
+ * This file is placed under the GPL.  Please see the file
+ * COPYING for more details.
+ *
+ *
+ * Takes tslib events and send them to uinput as
+ *   BTN_TOUCH, ABS_X, ABS_Y and ABS_PRESSURE values.
+ * Short tap send button event and longer tap send only coordinates.
+ * Tested only with Kodi application.
+ *
+ * code based on
+ *   tslib/src/ts_test.c
+ *   tslib/src/ts_calibrate.c
+ *   http://thiemonge.org/getting-started-with-uinput
+ *   http://lkcl.net/software/uinput/
+ *
+ * In memory of my mom and dad ...
+ */
+
+#include "config.h"
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <linux/fb.h>
+#include <linux/input.h>
+#include <linux/uinput.h>
+#include "tslib.h"
+#include "testutils.h"
+
+#define die(str, args...) do { \
+    perror(str); \
+    exit(EXIT_FAILURE); \
+  } while(0);
+
+#define SET_ABS_MINMAX(dev, arg, min, max) do { \
+    (dev).absmin[arg] = min; \
+    (dev).absmax[arg] = max; \
+  } while(0);
+
+#define CANCEL_CALIBRATION if (! calibration_mode) return; else {}
+
+#define SOCK_PATH "/tmp/ts_calibrate.socket"
+
+#define CROSSHAIR_STR1 "Top left"
+#define CROSSHAIR_STR2 "Top right"
+#define CROSSHAIR_STR3 "Bottom right"
+#define CROSSHAIR_STR4 "Bottom left"
+#define CROSSHAIR_STR5 "Center"
+
+typedef struct {
+  int x[5], xfb[5];
+  int y[5], yfb[5];
+  int a[7];
+} calibration;
+
+char *uinput_names[] = {"/dev/uinput", "/dev/input/uinput", "/dev/misc/uinput"};
+#define UINPUT_NAMES_NUM ((int) (sizeof(uinput_names)/sizeof(char *)))
+
+__u32 xres = 0, yres = 0;
+struct timeval tv_short_tap = {0, 300};  /* sec, msec */
+bool calibration_mode = false;
+int sock = -1;
+
+static void daemonize() {
+  pid_t pid;
+
+  pid = fork();
+  if (pid == -1) {
+    die("failed to fork while daemonising (errno=%d)", errno)
+  } else if (pid != 0) {
+    exit(0);
+  }
+
+  umask(0);
+
+  if (setsid() == -1) {
+    die("failed to become a session leader while daemonising(errno=%d)", errno)
+  }
+
+  signal(SIGHUP,SIG_IGN);
+  pid=fork();
+  if (pid == -1) {
+    die("failed to fork while daemonizing (errno=%d)", errno)
+  } else if (pid != 0) {
+    exit(0);
+  }
+
+  if (chdir("/") == -1) {
+    die("failed to change working directory while daemonizing (errno=%d)", errno)
+  }
+
+  umask(0);
+  close(STDIN_FILENO);
+  close(STDOUT_FILENO);
+  close(STDERR_FILENO);
+
+  if (open("/dev/null", O_RDONLY) == -1) {
+    die("failed to reopen stdin while daemonizing (errno=%d)", errno)
+  }
+
+  if (open("/dev/null", O_WRONLY) == -1) {
+    die("failed to reopen stdout while daemonizing (errno=%d)", errno)
+  }
+
+  if (open("/dev/null", O_RDWR) == -1) {
+    die("failed to reopen stderr while daemonizing (errno=%d)", errno)
+  }
+}
+
+static void sig(int sig)
+{
+  fflush(stderr);
+  printf("signal %d caught\n", sig);
+  fflush(stdout);
+  exit(1);
+}
+
+static void set_ioctl(int fd, unsigned int cmd, __u16 value)
+{
+  if (ioctl(fd, cmd, value) < 0)
+    die("error: ioctl")
+}
+
+static int send_event(int fd, __u16 type, __u16 code, __s32 value)
+{
+  struct input_event event;
+  int ret;
+
+  memset(&event, 0, sizeof(event));
+  event.type = type;
+  event.code = code;
+  event.value = value;
+
+  ret = write(fd, &event, sizeof(event));
+  if (ret != sizeof(event)) {
+    fprintf(stderr, "Error on send_event");
+    return -1;
+  }
+
+  return 0;
+}
+
+static void signal_handler(int signal_number) {
+  if (signal_number == SIGUSR1)
+    calibration_mode = true;
+  else if (signal_number == SIGUSR2)
+    calibration_mode = false;
+  else
+    return;
+
+  printf("signal handler %d, current calibration_mode=%d\n", signal_number, calibration_mode == true ? 1 : 0);
+  if (calibration_mode) {
+    tv_short_tap.tv_sec += 600; /* little more time */
+  } else {
+    tv_short_tap.tv_sec -= 600;
+  }
+}
+
+static int perform_calibration(calibration *cal) {
+  int j;
+  float n, x, y, x2, y2, xy, z, zx, zy;
+  float det, a, b, c, e, f, i;
+  float scaling = 65536.0;
+
+// Get sums for matrix
+  n = x = y = x2 = y2 = xy = 0;
+  for(j=0;j<5;j++) {
+    n += 1.0;
+    x += (float)cal->x[j];
+    y += (float)cal->y[j];
+    x2 += (float)(cal->x[j]*cal->x[j]);
+    y2 += (float)(cal->y[j]*cal->y[j]);
+    xy += (float)(cal->x[j]*cal->y[j]);
+  }
+
+// Get determinant of matrix -- check if determinant is too small
+  det = n*(x2*y2 - xy*xy) + x*(xy*y - x*y2) + y*(x*xy - y*x2);
+  if(det < 0.1 && det > -0.1) {
+    printf("ts_calibrate: determinant is too small -- %f\n",det);
+    return 0;
+  }
+
+// Get elements of inverse matrix
+  a = (x2*y2 - xy*xy)/det;
+  b = (xy*y - x*y2)/det;
+  c = (x*xy - y*x2)/det;
+  e = (n*y2 - y*y)/det;
+  f = (x*y - n*xy)/det;
+  i = (n*x2 - x*x)/det;
+
+// Get sums for x calibration
+  z = zx = zy = 0;
+  for(j=0;j<5;j++) {
+    z += (float)cal->xfb[j];
+    zx += (float)(cal->xfb[j]*cal->x[j]);
+    zy += (float)(cal->xfb[j]*cal->y[j]);
+  }
+
+// Now multiply out to get the calibration for framebuffer x coord
+  cal->a[0] = (int)((a*z + b*zx + c*zy)*(scaling));
+  cal->a[1] = (int)((b*z + e*zx + f*zy)*(scaling));
+  cal->a[2] = (int)((c*z + f*zx + i*zy)*(scaling));
+
+  printf("%f %f %f\n",(a*z + b*zx + c*zy),
+        (b*z + e*zx + f*zy),
+        (c*z + f*zx + i*zy));
+
+// Get sums for y calibration
+  z = zx = zy = 0;
+  for(j=0;j<5;j++) {
+    z += (float)cal->yfb[j];
+    zx += (float)(cal->yfb[j]*cal->x[j]);
+    zy += (float)(cal->yfb[j]*cal->y[j]);
+  }
+
+// Now multiply out to get the calibration for framebuffer y coord
+  cal->a[3] = (int)((a*z + b*zx + c*zy)*(scaling));
+  cal->a[4] = (int)((b*z + e*zx + f*zy)*(scaling));
+  cal->a[5] = (int)((c*z + f*zx + i*zy)*(scaling));
+
+  printf("%f %f %f\n",(a*z + b*zx + c*zy),
+        (b*z + e*zx + f*zy),
+        (c*z + f*zx + i*zy));
+
+// If we got here, we're OK, so assign scaling to a[6] and return
+  cal->a[6] = (int)scaling;
+  return 1;
+/*
+// This code was here originally to just insert default values
+  for(j=0;j<7;j++) {
+    c->a[j]=0;
+  }
+  c->a[1] = c->a[5] = c->a[6] = 1;
+  return 1;
+*/
+}
+
+static void get_sample(struct tsdev *ts, calibration *cal,
+      int index, int x, int y, char *name)
+{
+  printf("getting sample for: %s\n", name);
+  getxy(ts, &cal->x[index], &cal->y[index]);
+  cal->xfb[index] = x;
+  cal->yfb[index] = y;
+  printf("%s: X = %4d Y = %4d\n", name, cal->x[index], cal->y[index]);
+}
+
+static void clearbuf(struct tsdev *ts)
+{
+  int fd = ts_fd(ts);
+  fd_set fdset;
+  struct timeval tv;
+  int nfds;
+  struct ts_sample sample;
+
+  while (1) {
+    FD_ZERO(&fdset);
+    FD_SET(fd, &fdset);
+
+    tv.tv_sec = 0;
+    tv.tv_usec = 0;
+
+    nfds = select(fd + 1, &fdset, NULL, NULL, &tv);
+    if (nfds == 0) break;
+
+    if (ts_read_raw(ts, &sample, 1) < 0) {
+      perror("ts_read");
+      exit(1);
+    }
+  }
+}
+
+/* we don't use fb but this function is called in case of an error */
+void close_framebuffer(void) {}
+
+static void send_socket_crosshair_str(char *str)
+{
+  if (send(sock, str, strlen(str), 0) == -1) {
+    printf("send error\n");
+  }
+}
+
+static void run_calibration(struct tsdev *ts)
+{
+  calibration cal;
+  int cal_fd;
+  char cal_buffer[256];
+  char *calfile;
+  unsigned int i, len;
+
+  send_socket_crosshair_str(CROSSHAIR_STR1);  /* show first touch point */
+  clearbuf(ts);
+  get_sample(ts, &cal, 0, 50,        50,        CROSSHAIR_STR1);
+  CANCEL_CALIBRATION
+  send_socket_crosshair_str(CROSSHAIR_STR2);
+  clearbuf(ts);
+  get_sample(ts, &cal, 1, xres - 50, 50,        CROSSHAIR_STR2);
+  CANCEL_CALIBRATION
+  send_socket_crosshair_str(CROSSHAIR_STR3);
+  clearbuf(ts);
+  get_sample(ts, &cal, 2, xres - 50, yres - 50, CROSSHAIR_STR3);
+  CANCEL_CALIBRATION
+  send_socket_crosshair_str(CROSSHAIR_STR4);
+  clearbuf(ts);
+  get_sample(ts, &cal, 3, 50,        yres - 50, CROSSHAIR_STR4);
+  CANCEL_CALIBRATION
+  send_socket_crosshair_str(CROSSHAIR_STR5);
+  clearbuf(ts);
+  get_sample(ts, &cal, 4, xres / 2,  yres / 2,  CROSSHAIR_STR5);
+  CANCEL_CALIBRATION
+  send_socket_crosshair_str("done");
+  clearbuf(ts);
+
+  if (perform_calibration(&cal)) {
+    printf ("Calibration constants: ");
+    for (i = 0; i < 7; i++)
+      printf("%d ", cal.a[i]);
+
+    printf("\n");
+    calfile = getenv("TSLIB_CALIBFILE");
+    if (calfile != NULL) {
+      cal_fd = open(calfile, O_CREAT | O_TRUNC | O_RDWR,
+                     S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+
+      if (cal_fd == -1) {
+        printf("Calibration failed - can't open calibration file %s.\n", calfile);
+        return;
+      }
+    } else {
+      cal_fd = open(TS_POINTERCAL, O_CREAT | O_TRUNC | O_RDWR,
+                     S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+
+      if (cal_fd == -1) {
+        printf("Calibration failed - can't open calibration file %s.\n", TS_POINTERCAL);
+        return;
+      }
+    }
+
+    len = sprintf(cal_buffer, "%d %d %d %d %d %d %d %d %d",
+                  cal.a[1], cal.a[2], cal.a[0],
+                  cal.a[4], cal.a[5], cal.a[3], cal.a[6],
+                  xres, yres);
+    write(cal_fd, cal_buffer, len);
+    close(cal_fd);
+  } else {
+    printf("Calibration failed - wrong data.\n");
+  }
+}
+
+int get_resolution(void)
+{
+  static char *fbdevice;
+  int fd;
+  static struct fb_var_screeninfo var;
+
+  fbdevice = getenv("TSLIB_FBDEVICE");
+  if (fbdevice == NULL)
+    return -1;
+
+  printf("using fb device: %s\n", fbdevice);
+  fd = open(fbdevice, O_RDWR);
+  if (fd == -1) {
+    perror("open fbdevice");
+    return -1;
+  }
+
+  if (ioctl(fd, FBIOGET_VSCREENINFO, &var) < 0) {
+    perror("ioctl FBIOGET_VSCREENINFO");
+    close(fd);
+    return -1;
+  }
+
+  xres = var.xres;
+  yres = var.yres;
+
+  close(fd);
+  return 0;
+}
+
+int main(int argc, char *argv[])
+{
+  int c;
+  char *tsdevice;
+  struct tsdev *ts;
+  int ret;
+  struct ts_sample samp;
+  int uinput_fd;
+  struct uinput_user_dev uidev;
+  int daemon = 0;
+  struct timeval tv_last;
+  struct timeval tv_sub;
+  char *touch_str;
+  int val;
+  struct sigaction sa;
+  struct sockaddr_un remote_addr;
+
+  touch_str = getenv("TSLIB_TAP_TIME");
+  if (touch_str != NULL) {
+    val = atoi(touch_str);
+    if (val < 1000) {
+      tv_short_tap.tv_sec = 0;
+      tv_short_tap.tv_usec = val;
+    } else {
+      tv_short_tap.tv_sec = val / 1000;
+      tv_short_tap.tv_usec = val % 1000;
+    }
+  }
+
+  get_resolution();
+
+  while ((c = getopt(argc, argv, "?dt:x:y:")) != -1) {
+    switch (c) {
+      case 'd':
+        daemon = 1;
+        break;
+      case 't':
+        val = atoi(optarg);
+        if (val < 1000) {
+          tv_short_tap.tv_sec = 0;
+          tv_short_tap.tv_usec = val;
+        } else {
+          tv_short_tap.tv_sec = val / 1000;
+          tv_short_tap.tv_usec = val % 1000;
+        }
+
+        break;
+      case 'x':
+        xres = atoi(optarg);
+        break;
+      case 'y':
+        yres = atoi(optarg);
+        break;
+      case '?':
+        if (isprint(optopt))
+          fprintf (stderr, "Unknown option '-%c'.\n", optopt);
+        else
+          fprintf (stderr, "Unknown option character '\\x%x'.\n", optopt);
+        return 1;
+      default:
+        die("getopt")
+    }
+  }
+
+  printf("resolution: %dx%d\n", xres, yres);
+
+  signal(SIGSEGV, sig);
+  signal(SIGINT, sig);
+  signal(SIGTERM, sig);
+
+  tsdevice = getenv("TSLIB_TSDEVICE");
+
+  if (tsdevice == NULL) {
+    errno = ENOENT;
+    die("error: TSLIB_TSDEVICE")
+  }
+
+  printf("using touch device: %s\n", tsdevice);
+
+  ts = ts_open(tsdevice, 0);  // 0 nonblock
+  if (!ts) {
+    die("ts_open")
+  }
+
+  if (ts_config(ts)) {
+    die("ts_config")
+  }
+
+  system("modprobe uinput");
+
+  for (c=0; c < UINPUT_NAMES_NUM; c++) {
+    uinput_fd = open(uinput_names[c], O_WRONLY | O_NONBLOCK);
+    if (uinput_fd >= 0)
+      break;
+  }
+
+  if (uinput_fd < 0)
+    die("error: opening uinput")
+
+  if (tv_short_tap.tv_sec == 0)
+    printf("Short tap time: %li msec\n", tv_short_tap.tv_usec);
+  else
+    printf("Short tap time: %li.%li sec\n", tv_short_tap.tv_sec, tv_short_tap.tv_usec);
+
+  memset (&sa, 0, sizeof (sa));
+  sa.sa_handler = &signal_handler;
+  sigaction(SIGUSR1, &sa, NULL);
+  sigaction(SIGUSR2, &sa, NULL);
+
+  if (daemon == 1) {
+    printf("daemonizing...\n");
+    daemonize();
+  }
+
+  set_ioctl(uinput_fd, UI_SET_EVBIT, EV_SYN);
+  set_ioctl(uinput_fd, UI_SET_EVBIT, EV_KEY);
+  set_ioctl(uinput_fd, UI_SET_KEYBIT, BTN_TOUCH);
+  set_ioctl(uinput_fd, UI_SET_EVBIT, EV_ABS);
+  set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_X);
+  set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_Y);
+  set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_PRESSURE);
+
+  memset(&uidev, 0, sizeof(uidev));
+
+  snprintf(uidev.name, UINPUT_MAX_NAME_SIZE, "tslib to uinput daemon");
+  SET_ABS_MINMAX(uidev, ABS_X, 0, xres)
+  SET_ABS_MINMAX(uidev, ABS_Y, 0, yres)
+  SET_ABS_MINMAX(uidev, ABS_PRESSURE, 0, 255)
+
+  uidev.id.bustype = BUS_USB;
+  uidev.id.vendor  = 0x34a5;
+  uidev.id.product = 0x67b8;
+  uidev.id.version = 1;
+
+  if (write(uinput_fd, &uidev, sizeof(uidev)) < 0)
+    die("error: write")
+
+  if (ioctl(uinput_fd, UI_DEV_CREATE) < 0)
+    die("error: ioctl UI_DEV_CREATE")
+
+  tv_short_tap.tv_usec *= 1000;   /* msec to usec */
+  timerclear(&tv_last);
+  while (1) {
+    touch_str = "";
+    if (calibration_mode) {
+      usleep(250000);   /* app become ready */
+      printf("calibration mode started\n");
+
+      sock = socket(AF_UNIX, SOCK_STREAM, 0);
+      if (sock == -1) {
+        die("socket");
+      }
+
+      printf("trying to connect\n");
+
+      remote_addr.sun_family = AF_UNIX;
+      strcpy(remote_addr.sun_path, SOCK_PATH);
+      val = strlen(remote_addr.sun_path) + sizeof(remote_addr.sun_family);
+      if (connect(sock, (struct sockaddr *) &remote_addr, val) == -1) {
+        calibration_mode = false;
+        close(sock);
+        printf("connect error, skip calibration\n");
+        usleep(200000);
+        continue;
+      }
+
+      printf("connected\n");
+      run_calibration(ts);
+      calibration_mode = false;
+      close(sock);
+      printf("calibration mode finished\n");
+    }
+
+    ret = ts_read(ts, &samp, 1);
+    if (ret < 0) {
+      usleep(200000);
+      continue;
+    } else if (ret == 0) {
+      /* can't grab ts device */
+      usleep(400000);
+    } else if (ret != 1)
+      continue;
+
+    send_event(uinput_fd, EV_ABS, ABS_X, samp.x);
+    send_event(uinput_fd, EV_ABS, ABS_Y, samp.y);
+
+    if (samp.pressure > 0) {  /* touched */
+      send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 255);
+      send_event(uinput_fd, EV_SYN, 0, 0);
+
+      if (timerisset(&tv_last) == false) {
+        memcpy(&tv_last, &samp.tv, sizeof(struct timeval)); /* touched first time */
+        touch_str = "touched first";
+      }
+    } else {  /* released */
+      timersub(&samp.tv, &tv_last, &tv_sub);
+      if (timercmp(&tv_sub, &tv_short_tap, <=)) {
+        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 255);
+        send_event(uinput_fd, EV_KEY, BTN_TOUCH, 1);
+        send_event(uinput_fd, EV_SYN, 0, 0);
+        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
+        send_event(uinput_fd, EV_KEY, BTN_TOUCH, 0);
+        send_event(uinput_fd, EV_SYN, 0, 0);
+
+        touch_str = "released and send button";
+      } else {
+        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
+        send_event(uinput_fd, EV_SYN, 0, 0);
+        touch_str = "released";
+      }
+
+      timerclear(&tv_last);
+    }
+
+    printf("%ld.%06ld: %6d %6d %6d  %s\n", samp.tv.tv_sec, samp.tv.tv_usec,
+          samp.x, samp.y, samp.pressure, touch_str);
+  }
+
+  if (ioctl(uinput_fd, UI_DEV_DESTROY) < 0)
+    die("error: ioctl UI_DEV_DESTROY")
+
+  close(uinput_fd);
+
+  return 0;
+}

From b64b63ac2fc791cad6e79cf9236c47b928960c2e Mon Sep 17 00:00:00 2001
From: vpeter4 <peter.vicman@gmail.com>
Date: Sat, 4 Jul 2015 13:46:56 +0200
Subject: [PATCH 03/11] ts_uinput_touch: add BTN_RIGHT event if tapped for more
 than 300 ms and less than a second BTN_RIGHT event is send

---
 tests/ts_uinput_touch.c | 38 ++++++++++++++++++++++++++------------
 1 file changed, 26 insertions(+), 12 deletions(-)
 mode change 100644 => 100755 tests/ts_uinput_touch.c

diff --git a/tests/ts_uinput_touch.c b/tests/ts_uinput_touch.c
old mode 100644
new mode 100755
index 60efc46..489a22f
--- a/tests/ts_uinput_touch.c
+++ b/tests/ts_uinput_touch.c
@@ -9,8 +9,9 @@
  *
  *
  * Takes tslib events and send them to uinput as
- *   BTN_TOUCH, ABS_X, ABS_Y and ABS_PRESSURE values.
- * Short tap send button event and longer tap send only coordinates.
+ *   BTN_TOUCH, BTN_RIGHT, ABS_X, ABS_Y and ABS_PRESSURE values.
+ * Short tap send button touch event, little longer tap send button right event
+ *   and longer tap send only coordinates.
  * Tested only with Kodi application.
  *
  * code based on
@@ -77,7 +78,8 @@ char *uinput_names[] = {"/dev/uinput", "/dev/input/uinput", "/dev/misc/uinput"};
 #define UINPUT_NAMES_NUM ((int) (sizeof(uinput_names)/sizeof(char *)))
 
 __u32 xres = 0, yres = 0;
-struct timeval tv_short_tap = {0, 300};  /* sec, msec */
+struct timeval tv_short_tap = {0, 300};  /* sec, msec, short tap sends BTN_TOUCH */
+struct timeval tv_right_tap = {1, 0};    /* sec, msec, longer tap sends BTN_RIGHT */
 bool calibration_mode = false;
 int sock = -1;
 
@@ -169,11 +171,6 @@ static void signal_handler(int signal_number) {
     return;
 
   printf("signal handler %d, current calibration_mode=%d\n", signal_number, calibration_mode == true ? 1 : 0);
-  if (calibration_mode) {
-    tv_short_tap.tv_sec += 600; /* little more time */
-  } else {
-    tv_short_tap.tv_sec -= 600;
-  }
 }
 
 static int perform_calibration(calibration *cal) {
@@ -501,6 +498,11 @@ int main(int argc, char *argv[])
   else
     printf("Short tap time: %li.%li sec\n", tv_short_tap.tv_sec, tv_short_tap.tv_usec);
 
+  if (tv_right_tap.tv_sec == 0)
+    printf("Right tap time: %li msec\n", tv_right_tap.tv_usec);
+  else
+    printf("Right tap time: %li.%li sec\n", tv_right_tap.tv_sec, tv_right_tap.tv_usec);
+
   memset (&sa, 0, sizeof (sa));
   sa.sa_handler = &signal_handler;
   sigaction(SIGUSR1, &sa, NULL);
@@ -511,10 +513,11 @@ int main(int argc, char *argv[])
     daemonize();
   }
 
-  set_ioctl(uinput_fd, UI_SET_EVBIT, EV_SYN);
-  set_ioctl(uinput_fd, UI_SET_EVBIT, EV_KEY);
+  set_ioctl(uinput_fd, UI_SET_EVBIT,  EV_SYN);
+  set_ioctl(uinput_fd, UI_SET_EVBIT,  EV_KEY);
   set_ioctl(uinput_fd, UI_SET_KEYBIT, BTN_TOUCH);
-  set_ioctl(uinput_fd, UI_SET_EVBIT, EV_ABS);
+  set_ioctl(uinput_fd, UI_SET_KEYBIT, BTN_RIGHT);
+  set_ioctl(uinput_fd, UI_SET_EVBIT,  EV_ABS);
   set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_X);
   set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_Y);
   set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_PRESSURE);
@@ -538,6 +541,8 @@ int main(int argc, char *argv[])
     die("error: ioctl UI_DEV_CREATE")
 
   tv_short_tap.tv_usec *= 1000;   /* msec to usec */
+  tv_right_tap.tv_usec *= 1000;   /* msec to usec */
+
   timerclear(&tv_last);
   while (1) {
     touch_str = "";
@@ -601,7 +606,16 @@ int main(int argc, char *argv[])
         send_event(uinput_fd, EV_KEY, BTN_TOUCH, 0);
         send_event(uinput_fd, EV_SYN, 0, 0);
 
-        touch_str = "released and send button";
+        touch_str = "released and send tap";
+      } else if (timercmp(&tv_sub, &tv_right_tap, <=)) {
+        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 255);
+        send_event(uinput_fd, EV_KEY, BTN_RIGHT, 1);
+        send_event(uinput_fd, EV_SYN, 0, 0);
+        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
+        send_event(uinput_fd, EV_KEY, BTN_RIGHT, 0);
+        send_event(uinput_fd, EV_SYN, 0, 0);
+
+        touch_str = "released and send right";
       } else {
         send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
         send_event(uinput_fd, EV_SYN, 0, 0);

From 0c95545167711eb2e906c8ef885956f3395e945a Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Mon, 31 Aug 2015 10:52:51 +0200
Subject: [PATCH 04/11] Add Waveshare touchscreen raw module inspiration from
 derekhe: https://github.com/derekhe/wavesahre-7inch-touchscreen-driver

---
 configure.ac            |   1 +
 plugins/Makefile.am     |  13 +++-
 plugins/plugins.h       |   1 +
 plugins/waveshare-raw.c | 202 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/Makefile.am         |   4 +
 5 files changed, 220 insertions(+), 1 deletion(-)
 create mode 100644 plugins/waveshare-raw.c

diff --git a/configure.ac b/configure.ac
index 6984002..598ede7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -70,6 +70,7 @@ TSLIB_CHECK_MODULE([input], [yes], [Enable building of generic input raw module
 TSLIB_CHECK_MODULE([touchkit], [yes], [Enable building of serial TouchKit raw module (Linux /dev/ttySX support)])
 TSLIB_CHECK_MODULE([galax], [yes], [Enable building of HID USB eGalax raw module (Linux /dev/hiddevN support)])
 TSLIB_CHECK_MODULE([st1232], [yes], [Enable building of ST1232 raw module (Linux /dev/input/eventN support)])
+TSLIB_CHECK_MODULE([waveshare], [yes], [Enable building of WaveShare raw module (Linux /dev/hidrawN support)])
 
 
 
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index e8e89e0..98881b3 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -127,6 +127,12 @@ else
 ST1232_MODULE =
 endif
 
+if ENABLE_WAVESHARE_MODULE
+WAVESHARE_MODULE = waveshare.la
+else
+WAVESHARE_MODULE =
+endif
+
 pluginexec_LTLIBRARIES = \
 	$(LINEAR_MODULE) \
 	$(DEJITTER_MODULE) \
@@ -145,7 +151,8 @@ pluginexec_LTLIBRARIES = \
 	$(GALAX_MODULE) \
 	$(TOUCHKIT_MODULE) \
 	$(CY8MRLN_PALMPRE_MODULE) \
-	$(ST1232_MODULE)
+	$(ST1232_MODULE) \
+	$(WAVESHARE_MODULE)
   
 variance_la_SOURCES	= variance.c
 variance_la_LDFLAGS	= -module $(LTVSN)
@@ -208,3 +215,7 @@ cy8mrln_palmpre_la_LDFLAGS = -module $(LTVSN)
 st1232_la_SOURCES = st1232-raw.c
 st1232_la_LDFLAGS = -module $(LTVSN)
 st1232_la_LIBADD = $(top_builddir)/src/libts.la
+
+waveshare_la_SOURCES = waveshare-raw.c
+waveshare_la_LDFLAGS = -module $(LTVSN)
+waveshare_la_LIBADD = $(top_builddir)/src/libts.la
diff --git a/plugins/plugins.h b/plugins/plugins.h
index d78877e..f347e25 100644
--- a/plugins/plugins.h
+++ b/plugins/plugins.h
@@ -17,3 +17,4 @@ TSLIB_DECLARE_MODULE(tatung);
 TSLIB_DECLARE_MODULE(input);
 TSLIB_DECLARE_MODULE(cy8mrln_palmpre);
 TSLIB_DECLARE_MODULE(st1232);
+TSLIB_DECLARE_MODULE(waveshare);
diff --git a/plugins/waveshare-raw.c b/plugins/waveshare-raw.c
new file mode 100644
index 0000000..ff13055
--- /dev/null
+++ b/plugins/waveshare-raw.c
@@ -0,0 +1,202 @@
+/*
+ * tslib driver for WaveShare touchscreens
+ * Copyright (C) 2015 Peter Vicman
+ * inspiration from derekhe: https://github.com/derekhe/wavesahre-7inch-touchscreen-driver
+ *
+ * This file is placed under the LGPL.  Please see the file COPYING for more
+ * details.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <linux/hidraw.h>
+#include <stdbool.h>
+
+#include "config.h"
+#include "tslib-private.h"
+
+struct tslib_input {
+  struct tslib_module_info module;
+  int vendor;
+  int product;
+  int len;
+};
+
+static int waveshare_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
+{
+  static bool reopen = true;
+  struct stat devstat;
+  struct hidraw_devinfo info;
+  char name_buf[512];
+  int cnt;
+  bool found = false;
+  struct tslib_input *i = (struct tslib_input *) inf;
+  struct tsdev *ts = inf->dev;
+  struct tsdev *ts_tmp;
+  char *buf;
+  int ret;
+
+  if (reopen == true) {
+    reopen = false;
+
+    if (i->vendor > 0 && i->product > 0) {
+      fprintf(stderr, "waveshare: searching for device using hidraw....\n");
+      for (cnt=0; cnt<HIDRAW_MAX_DEVICES; cnt++) {
+        snprintf(name_buf, sizeof(buf), "/dev/hidraw%d", cnt);
+        fprintf(stderr, "waveshare: device: %s\n", name_buf);
+        ret = stat(name_buf, &devstat);
+        if (ret < 0)
+          continue;
+
+        ts_tmp = ts_open(name_buf, 0);
+        if (!ts_tmp) {
+          continue;
+        }
+
+        fprintf(stderr, "  opened\n");
+        ret = ioctl(ts_tmp->fd, HIDIOCGRAWINFO, &info);
+        if (ret < 0) {
+          ts_close(ts_tmp);
+          continue;
+        }
+
+        info.vendor &= 0xFFFF;
+        info.product &= 0xFFFF;
+        fprintf(stderr, "  vid=%04X, pid=%04X\n", info.vendor, info.product);
+
+        if (i->vendor == info.vendor && i->product == info.product) {
+          if (ts->fd > 0)
+            close(ts->fd);
+
+          ts->fd = ts_tmp->fd;
+          free(ts_tmp);
+          found = true;
+          fprintf(stderr, "  correct device\n");
+          break;
+        }
+
+        ts_close(ts_tmp);
+      } /* for HIDRAW_MAX_DEVICES */
+
+      if (found == false) {
+        return -1;
+      }
+    } /* vid/pid set */
+  } /* reopen */
+
+  buf = alloca(i->len * nr);
+
+  ret = read(ts->fd, buf, i->len * nr);
+  if(ret > 0) {
+    while(ret >= (int) i->len) {
+      /*
+        0000271: aa01 00e4 0139 bb01 01e0 0320 01e0 0320 01e0 0320 01e0 0320 cc  .....9..... ... ... ... .
+
+        "aa" is start of the command, "01" means clicked while "00" means unclicked.
+        "00e4" and "0139" is the X,Y position (HEX).
+        "bb" is start of multi-touch, and the following bytes are the position of each point.
+      */
+      samp->pressure = buf[1] & 0xff;
+      samp->x = ((buf[2] & 0xff) << 8) | (buf[3] & 0xff);
+      samp->y = ((buf[4] & 0xff) << 8) | (buf[5] & 0xff);
+      gettimeofday(&samp->tv, NULL);
+#ifdef DEBUG
+        fprintf(stderr, "waveshare raw: %d %d %d\n", samp->x, samp->y, samp->pressure);
+        fprintf(stderr, "%x %x %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
+#endif
+      samp++;
+      buf += i->len;
+      ret -= i->len;
+    }
+  } else {
+    return -1;
+  }
+
+  return nr;
+}
+
+static const struct tslib_ops waveshare_ops =
+{
+  .read = waveshare_read,
+};
+
+static int parse_vid_pid(struct tslib_module_info *inf, char *str, void *data)
+{
+  struct tslib_input *i = (struct tslib_input *)inf;
+
+  if (strlen(str) < 9 || (int) data != 1)
+    return 0;   /* -1 */
+
+  str[4] = str[9] = '\0';
+  i->vendor = strtol(&str[0], NULL, 16);
+  i->product = strtol(&str[5], NULL, 16);
+//#ifdef DEBUG
+  fprintf(stderr, "waveshare vid:pid - %04X:%04X\n", i->vendor, i->product);
+//#endif /*DEBUG*/
+  return 0;
+}
+
+static int parse_len(struct tslib_module_info *inf, char *str, void *data)
+{
+  struct tslib_input *i = (struct tslib_input *)inf;
+  int v;
+  int err = errno;
+
+  v = atoi(str);
+
+  if (v < 0)
+    return -1;
+
+  errno = err;
+  switch ((int) data) {
+    case 1:
+      i->len = v;
+      fprintf(stderr, "waveshare raw data len: %d bytes\n", i->len);
+      break;
+    default:
+      return -1;
+  }
+  return 0;
+}
+
+static const struct tslib_vars raw_vars[] =
+{
+  { "vid_pid", (void *) 1, parse_vid_pid },
+  { "len", (void *) 1, parse_len },
+};
+
+#define NR_VARS (sizeof(raw_vars) / sizeof(raw_vars[0]))
+
+TSAPI struct tslib_module_info *waveshare_mod_init(struct tsdev *dev, const char *params)
+{
+  struct tslib_input *i;
+
+  (void) dev;
+
+  i = malloc(sizeof(struct tslib_input));
+  if (i == NULL)
+    return NULL;
+
+  i->module.ops = &waveshare_ops;
+  i->vendor = 0;
+  i->product = 0;
+  i->len = 25;
+
+  if (tslib_parse_vars(&i->module, raw_vars, NR_VARS, params)) {
+    free(i);
+    return NULL;
+  }
+
+  return &(i->module);
+}
+
+#ifndef TSLIB_STATIC_WAVESHARE_MODULE
+  TSLIB_MODULE_INIT(waveshare_mod_init);
+#endif
diff --git a/src/Makefile.am b/src/Makefile.am
index b561aa8..a8fded9 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -75,6 +75,10 @@ if ENABLE_STATIC_ST1232_MODULE
 libts_la_SOURCES += $(top_srcdir)/plugins/st1232-raw.c
 endif
 
+if ENABLE_STATIC_WAVESHARE_MODULE
+libts_la_SOURCES += $(top_srcdir)/plugins/waveshare-raw.c
+endif
+
 libts_la_LDFLAGS = -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
 		   -release $(LT_RELEASE) -export-dynamic
 libts_la_LIBADD  = -ldl

From 72128c5f16db89d7b644dd184c1b1c6dbe6ef79e Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Sun, 20 Sep 2015 10:30:33 +0200
Subject: [PATCH 05/11] waveshare: remove reopening device based on vid/pid

---
 plugins/waveshare-raw.c | 76 -------------------------------------------------
 1 file changed, 76 deletions(-)

diff --git a/plugins/waveshare-raw.c b/plugins/waveshare-raw.c
index ff13055..0839af0 100644
--- a/plugins/waveshare-raw.c
+++ b/plugins/waveshare-raw.c
@@ -24,73 +24,16 @@
 
 struct tslib_input {
   struct tslib_module_info module;
-  int vendor;
-  int product;
   int len;
 };
 
 static int waveshare_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
 {
-  static bool reopen = true;
-  struct stat devstat;
-  struct hidraw_devinfo info;
-  char name_buf[512];
-  int cnt;
-  bool found = false;
   struct tslib_input *i = (struct tslib_input *) inf;
   struct tsdev *ts = inf->dev;
-  struct tsdev *ts_tmp;
   char *buf;
   int ret;
 
-  if (reopen == true) {
-    reopen = false;
-
-    if (i->vendor > 0 && i->product > 0) {
-      fprintf(stderr, "waveshare: searching for device using hidraw....\n");
-      for (cnt=0; cnt<HIDRAW_MAX_DEVICES; cnt++) {
-        snprintf(name_buf, sizeof(buf), "/dev/hidraw%d", cnt);
-        fprintf(stderr, "waveshare: device: %s\n", name_buf);
-        ret = stat(name_buf, &devstat);
-        if (ret < 0)
-          continue;
-
-        ts_tmp = ts_open(name_buf, 0);
-        if (!ts_tmp) {
-          continue;
-        }
-
-        fprintf(stderr, "  opened\n");
-        ret = ioctl(ts_tmp->fd, HIDIOCGRAWINFO, &info);
-        if (ret < 0) {
-          ts_close(ts_tmp);
-          continue;
-        }
-
-        info.vendor &= 0xFFFF;
-        info.product &= 0xFFFF;
-        fprintf(stderr, "  vid=%04X, pid=%04X\n", info.vendor, info.product);
-
-        if (i->vendor == info.vendor && i->product == info.product) {
-          if (ts->fd > 0)
-            close(ts->fd);
-
-          ts->fd = ts_tmp->fd;
-          free(ts_tmp);
-          found = true;
-          fprintf(stderr, "  correct device\n");
-          break;
-        }
-
-        ts_close(ts_tmp);
-      } /* for HIDRAW_MAX_DEVICES */
-
-      if (found == false) {
-        return -1;
-      }
-    } /* vid/pid set */
-  } /* reopen */
-
   buf = alloca(i->len * nr);
 
   ret = read(ts->fd, buf, i->len * nr);
@@ -127,22 +70,6 @@ static const struct tslib_ops waveshare_ops =
   .read = waveshare_read,
 };
 
-static int parse_vid_pid(struct tslib_module_info *inf, char *str, void *data)
-{
-  struct tslib_input *i = (struct tslib_input *)inf;
-
-  if (strlen(str) < 9 || (int) data != 1)
-    return 0;   /* -1 */
-
-  str[4] = str[9] = '\0';
-  i->vendor = strtol(&str[0], NULL, 16);
-  i->product = strtol(&str[5], NULL, 16);
-//#ifdef DEBUG
-  fprintf(stderr, "waveshare vid:pid - %04X:%04X\n", i->vendor, i->product);
-//#endif /*DEBUG*/
-  return 0;
-}
-
 static int parse_len(struct tslib_module_info *inf, char *str, void *data)
 {
   struct tslib_input *i = (struct tslib_input *)inf;
@@ -168,7 +95,6 @@ static int parse_len(struct tslib_module_info *inf, char *str, void *data)
 
 static const struct tslib_vars raw_vars[] =
 {
-  { "vid_pid", (void *) 1, parse_vid_pid },
   { "len", (void *) 1, parse_len },
 };
 
@@ -185,8 +111,6 @@ TSAPI struct tslib_module_info *waveshare_mod_init(struct tsdev *dev, const char
     return NULL;
 
   i->module.ops = &waveshare_ops;
-  i->vendor = 0;
-  i->product = 0;
   i->len = 25;
 
   if (tslib_parse_vars(&i->module, raw_vars, NR_VARS, params)) {

From 8b6a678e507211d5d51081655af244561a931d8f Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Sun, 20 Sep 2015 10:42:31 +0200
Subject: [PATCH 06/11] ts_reconfig: reload all modules useful to reload
 calibration data without closing and opening device

---
 src/Makefile.am   |  2 +-
 src/ts_reconfig.c | 48 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/tslib.h       |  5 +++++
 3 files changed, 54 insertions(+), 1 deletion(-)
 create mode 100644 src/ts_reconfig.c

diff --git a/src/Makefile.am b/src/Makefile.am
index a8fded9..606a5ae 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -17,7 +17,7 @@ include_HEADERS  = tslib.h
 lib_LTLIBRARIES  = libts.la
 libts_la_SOURCES = ts_attach.c ts_close.c ts_config.c ts_error.c \
 		   ts_fd.c ts_load_module.c ts_open.c ts_parse_vars.c \
-		   ts_read.c ts_read_raw.c ts_option.c
+		   ts_read.c ts_read_raw.c ts_option.c ts_reconfig.c
 
 if ENABLE_STATIC_LINEAR_MODULE
 libts_la_SOURCES += $(top_srcdir)/plugins/linear.c
diff --git a/src/ts_reconfig.c b/src/ts_reconfig.c
new file mode 100644
index 0000000..c94ec3e
--- /dev/null
+++ b/src/ts_reconfig.c
@@ -0,0 +1,48 @@
+/*
+ *  tslib/src/ts_reconfig.c
+ *    based on tslib/src/ts_close.c
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This file is placed under the LGPL.  Please see the file
+ * COPYING for more details.
+ *
+ *
+ * Reloads all modules - useful to reload calibration data.
+ */
+#include "config.h"
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <dlfcn.h>
+
+#include "tslib-private.h"
+
+int ts_reconfig(struct tsdev *ts)
+{
+	void *handle;
+	int ret;
+	struct tslib_module_info *info, *next;
+	int fd;
+	
+	info = ts->list;
+	while(info) {
+		/* Save the "next" pointer now because info will be freed */
+		next = info->next;
+		
+		handle = info->handle;
+		info->ops->fini(info);
+		if (handle)
+			dlclose(handle);
+		
+		info = next;
+	}
+
+	fd = ts->fd;	/* save temp */
+	memset(ts, 0, sizeof(struct tsdev));
+	ts->fd = fd;
+
+	ret = ts_config(ts);
+	return ret;
+}
diff --git a/src/tslib.h b/src/tslib.h
index df8e284..28156ba 100644
--- a/src/tslib.h
+++ b/src/tslib.h
@@ -57,6 +57,11 @@ enum ts_param {
 TSAPI int ts_close(struct tsdev *);
 
 /*
+ * Reloads all modules - useful to reload calibration data.
+ */
+TSAPI int ts_reconfig(struct tsdev *);
+
+/*
  * Configure the touchscreen device.
  */
 TSAPI int ts_config(struct tsdev *);

From df81ed55ed9c99a8636f0b8524e0c5da0d00d33d Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Sun, 20 Sep 2015 10:45:55 +0200
Subject: [PATCH 07/11] ts_uinput_touch: reload modules (and calibration data)
 automatically after calibration and on SIGHUP signal

---
 tests/ts_uinput_touch.c | 67 +++++++++++++++++++++++++++++++++++--------------
 1 file changed, 48 insertions(+), 19 deletions(-)

diff --git a/tests/ts_uinput_touch.c b/tests/ts_uinput_touch.c
index 489a22f..871c5e4 100755
--- a/tests/ts_uinput_touch.c
+++ b/tests/ts_uinput_touch.c
@@ -74,6 +74,7 @@ typedef struct {
   int a[7];
 } calibration;
 
+struct tsdev *ts = NULL;
 char *uinput_names[] = {"/dev/uinput", "/dev/input/uinput", "/dev/misc/uinput"};
 #define UINPUT_NAMES_NUM ((int) (sizeof(uinput_names)/sizeof(char *)))
 
@@ -99,7 +100,7 @@ static void daemonize() {
     die("failed to become a session leader while daemonising(errno=%d)", errno)
   }
 
-  signal(SIGHUP,SIG_IGN);
+  /* signal(SIGHUP,SIG_IGN); */
   pid=fork();
   if (pid == -1) {
     die("failed to fork while daemonizing (errno=%d)", errno)
@@ -129,7 +130,7 @@ static void daemonize() {
   }
 }
 
-static void sig(int sig)
+static void signal_end(int sig)
 {
   fflush(stderr);
   printf("signal %d caught\n", sig);
@@ -163,7 +164,15 @@ static int send_event(int fd, __u16 type, __u16 code, __s32 value)
 }
 
 static void signal_handler(int signal_number) {
-  if (signal_number == SIGUSR1)
+	if (signal_number == SIGHUP) {
+  	/* reload modules (and calibration data) */
+  	printf("signal handler %d, reconfig ts\n", signal_number);
+  	if (ts_reconfig(ts)) {
+  	  die("ts_reconfig")
+	  }
+	  
+	  return;
+	} else if (signal_number == SIGUSR1)
     calibration_mode = true;
   else if (signal_number == SIGUSR2)
     calibration_mode = false;
@@ -366,25 +375,25 @@ static void run_calibration(struct tsdev *ts)
 
 int get_resolution(void)
 {
-  static char *fbdevice;
+  char *env_str;
   int fd;
   static struct fb_var_screeninfo var;
 
-  fbdevice = getenv("TSLIB_FBDEVICE");
-  if (fbdevice == NULL)
-    return -1;
+  env_str = getenv("TSLIB_FBDEVICE");
+  if (env_str == NULL)
+    goto not_found;
 
-  printf("using fb device: %s\n", fbdevice);
-  fd = open(fbdevice, O_RDWR);
+  printf("using fb device: %s\n", env_str);
+  fd = open(env_str, O_RDWR);
   if (fd == -1) {
     perror("open fbdevice");
-    return -1;
+    goto not_found;
   }
 
   if (ioctl(fd, FBIOGET_VSCREENINFO, &var) < 0) {
     perror("ioctl FBIOGET_VSCREENINFO");
     close(fd);
-    return -1;
+    goto not_found;
   }
 
   xres = var.xres;
@@ -392,13 +401,28 @@ int get_resolution(void)
 
   close(fd);
   return 0;
+
+not_found:
+	env_str = getenv("TSLIB_RES_X");
+	if (env_str != NULL)
+	  xres = atoi(env_str);
+
+	env_str = getenv("TSLIB_RES_Y");
+	if (env_str != NULL)
+	  yres = atoi(env_str);
+	
+	if (xres == 0 || yres == 0) {
+		xres = yres = 0;
+		return -1;
+	}
+	
+	return 0;
 }
 
 int main(int argc, char *argv[])
 {
   int c;
   char *tsdevice;
-  struct tsdev *ts;
   int ret;
   struct ts_sample samp;
   int uinput_fd;
@@ -423,7 +447,7 @@ int main(int argc, char *argv[])
     }
   }
 
-  get_resolution();
+  ret = get_resolution();
 
   while ((c = getopt(argc, argv, "?dt:x:y:")) != -1) {
     switch (c) {
@@ -460,12 +484,11 @@ int main(int argc, char *argv[])
 
   printf("resolution: %dx%d\n", xres, yres);
 
-  signal(SIGSEGV, sig);
-  signal(SIGINT, sig);
-  signal(SIGTERM, sig);
+  signal(SIGSEGV, signal_end);
+  signal(SIGINT, signal_end);
+  signal(SIGTERM, signal_end);
 
   tsdevice = getenv("TSLIB_TSDEVICE");
-
   if (tsdevice == NULL) {
     errno = ENOENT;
     die("error: TSLIB_TSDEVICE")
@@ -482,7 +505,7 @@ int main(int argc, char *argv[])
     die("ts_config")
   }
 
-  system("modprobe uinput");
+  ret = system("modprobe uinput");
 
   for (c=0; c < UINPUT_NAMES_NUM; c++) {
     uinput_fd = open(uinput_names[c], O_WRONLY | O_NONBLOCK);
@@ -505,6 +528,7 @@ int main(int argc, char *argv[])
 
   memset (&sa, 0, sizeof (sa));
   sa.sa_handler = &signal_handler;
+  sigaction(SIGHUP, &sa, NULL);
   sigaction(SIGUSR1, &sa, NULL);
   sigaction(SIGUSR2, &sa, NULL);
 
@@ -572,7 +596,12 @@ int main(int argc, char *argv[])
       run_calibration(ts);
       calibration_mode = false;
       close(sock);
-      printf("calibration mode finished\n");
+      printf("calibration mode finished, reload plugins\n");
+
+      clearbuf(ts);
+      if (ts_reconfig(ts)) {
+        die("ts_reconfig")
+      }
     }
 
     ret = ts_read(ts, &samp, 1);

From dbf1c882dbc239065df422f9e16da955c0b7653f Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Sun, 20 Sep 2015 10:47:44 +0200
Subject: [PATCH 08/11] plugins: compile statically

---
 plugins/Makefile.am    |  2 ++
 plugins/dmc-raw.c      |  6 +++++-
 plugins/plugins.h      |  5 ++++-
 plugins/touchkit-raw.c |  6 +++++-
 src/Makefile.am        | 12 ++++++++++++
 src/ts_load_module.c   | 12 ++++++++++++
 6 files changed, 40 insertions(+), 3 deletions(-)

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 98881b3..87fa18b 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -194,6 +194,7 @@ tatung_la_LDFLAGS	= -module $(LTVSN)
 
 dmc_la_SOURCES		= dmc-raw.c
 dmc_la_LDFLAGS		= -module $(LTVSN)
+dmc_la_LIBADD			= $(top_builddir)/src/libts.la
 
 input_la_SOURCES	= input-raw.c
 input_la_LDFLAGS	= -module $(LTVSN)
@@ -205,6 +206,7 @@ galax_la_LIBADD = $(top_builddir)/src/libts.la
 
 touchkit_la_SOURCES	= touchkit-raw.c
 touchkit_la_LDFLAGS	= -module $(LTVSN)
+touchkit_la_LIBADD	= $(top_builddir)/src/libts.la
 
 linear_h2200_la_SOURCES	= linear-h2200.c
 linear_h2200_la_LDFLAGS	= -module $(LTVSN)
diff --git a/plugins/dmc-raw.c b/plugins/dmc-raw.c
index f9f5381..59980cc 100644
--- a/plugins/dmc-raw.c
+++ b/plugins/dmc-raw.c
@@ -123,7 +123,7 @@ static const struct tslib_ops dmc_ops =
 	.read	= dmc_read,
 };
 
-TSAPI struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+TSAPI struct tslib_module_info *dmc_mod_init(struct tsdev *dev, const char *params)
 {
 	struct tslib_dmc *m;
 
@@ -137,3 +137,7 @@ TSAPI struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
 	m->module.ops = &dmc_ops;
 	return (struct tslib_module_info*)m;
 }
+
+#ifndef TSLIB_STATIC_DMC_MODULE
+	TSLIB_MODULE_INIT(dmc_mod_init);
+#endif
diff --git a/plugins/plugins.h b/plugins/plugins.h
index f347e25..798f9b3 100644
--- a/plugins/plugins.h
+++ b/plugins/plugins.h
@@ -6,7 +6,6 @@ TSLIB_DECLARE_MODULE(dejitter);
 TSLIB_DECLARE_MODULE(linear_h2200);
 TSLIB_DECLARE_MODULE(variance);
 TSLIB_DECLARE_MODULE(pthres);
-
 TSLIB_DECLARE_MODULE(ucb1x00);
 TSLIB_DECLARE_MODULE(corgi);
 TSLIB_DECLARE_MODULE(collie);
@@ -16,5 +15,9 @@ TSLIB_DECLARE_MODULE(arctic2);
 TSLIB_DECLARE_MODULE(tatung);
 TSLIB_DECLARE_MODULE(input);
 TSLIB_DECLARE_MODULE(cy8mrln_palmpre);
+TSLIB_DECLARE_MODULE(galax);
+TSLIB_DECLARE_MODULE(dmc);
+TSLIB_DECLARE_MODULE(touchkit);
 TSLIB_DECLARE_MODULE(st1232);
 TSLIB_DECLARE_MODULE(waveshare);
+
diff --git a/plugins/touchkit-raw.c b/plugins/touchkit-raw.c
index e072f21..68179a3 100644
--- a/plugins/touchkit-raw.c
+++ b/plugins/touchkit-raw.c
@@ -144,7 +144,7 @@ static const struct tslib_ops touchkit_ops = {
 	.read = touchkit_read,
 };
 
-TSAPI struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+TSAPI struct tslib_module_info *touchkit_mod_init(struct tsdev *dev, const char *params)
 {
 	struct tslib_module_info *m;
 
@@ -155,3 +155,7 @@ TSAPI struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
 	m->ops = &touchkit_ops;
 	return m;
 }
+
+#ifndef TSLIB_STATIC_TOUCHKIT_MODULE
+	TSLIB_MODULE_INIT(touchkit_mod_init);
+#endif
diff --git a/src/Makefile.am b/src/Makefile.am
index 606a5ae..2f31519 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -71,6 +71,18 @@ if ENABLE_STATIC_INPUT_MODULE
 libts_la_SOURCES += $(top_srcdir)/plugins/input-raw.c
 endif
 
+if ENABLE_STATIC_DMC_MODULE
+libts_la_SOURCES += $(top_srcdir)/plugins/dmc-raw.c
+endif
+
+if ENABLE_STATIC_GALAX_MODULE
+libts_la_SOURCES += $(top_srcdir)/plugins/galax-raw.c
+endif
+
+if ENABLE_STATIC_TOUCHKIT_MODULE
+libts_la_SOURCES += $(top_srcdir)/plugins/touchkit-raw.c
+endif
+
 if ENABLE_STATIC_ST1232_MODULE
 libts_la_SOURCES += $(top_srcdir)/plugins/st1232-raw.c
 endif
diff --git a/src/ts_load_module.c b/src/ts_load_module.c
index 886ca0a..903c921 100644
--- a/src/ts_load_module.c
+++ b/src/ts_load_module.c
@@ -76,6 +76,18 @@ static const struct {
 #ifdef TSLIB_STATIC_ST1232_MODULE
 	{ "st1232", st1232_mod_init },
 #endif
+#ifdef TSLIB_STATIC_CY8MRLN_PALMPRE_MODULE
+	{ "cy8mrln-palmpre", cy8mrln_palmpre_mod_init },
+#endif
+#ifdef TSLIB_STATIC_DMC_MODULE
+	{ "dmc", dmc_mod_init },
+#endif
+#ifdef TSLIB_STATIC_TOUCHKIT_MODULE
+	{ "touchkit", touchkit_mod_init },
+#endif
+#ifdef TSLIB_STATIC_WAVESHARE_MODULE
+	{ "waveshare", waveshare_mod_init },
+#endif
 };
 
 #define countof(arr) (sizeof(arr) / sizeof((arr)[0]))

From 72d2fe9e2ff18a9589510fd28e485b238a7bcbff Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Mon, 21 Sep 2015 09:36:38 +0200
Subject: [PATCH 09/11] file permission, tabs

---
 plugins/Makefile.am     | 2 +-
 tests/ts_uinput_touch.c | 0
 2 files changed, 1 insertion(+), 1 deletion(-)
 mode change 100755 => 100644 tests/ts_uinput_touch.c

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 87fa18b..4ed04c1 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -194,7 +194,7 @@ tatung_la_LDFLAGS	= -module $(LTVSN)
 
 dmc_la_SOURCES		= dmc-raw.c
 dmc_la_LDFLAGS		= -module $(LTVSN)
-dmc_la_LIBADD			= $(top_builddir)/src/libts.la
+dmc_la_LIBADD		= $(top_builddir)/src/libts.la
 
 input_la_SOURCES	= input-raw.c
 input_la_LDFLAGS	= -module $(LTVSN)
diff --git a/tests/ts_uinput_touch.c b/tests/ts_uinput_touch.c
old mode 100755
new mode 100644

From aff635ded1b41ade1b2cf2203cdf30f7fcd61127 Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Sat, 10 Oct 2015 21:24:53 +0200
Subject: [PATCH 10/11] ts_uinput_touch: remove button right event because it
 breaks scrollbar, context menu is open on few seconds tap

---
 tests/ts_uinput_touch.c | 141 ++++++++++++------------------------------------
 1 file changed, 35 insertions(+), 106 deletions(-)

diff --git a/tests/ts_uinput_touch.c b/tests/ts_uinput_touch.c
index 871c5e4..92db9ce 100644
--- a/tests/ts_uinput_touch.c
+++ b/tests/ts_uinput_touch.c
@@ -9,9 +9,7 @@
  *
  *
  * Takes tslib events and send them to uinput as
- *   BTN_TOUCH, BTN_RIGHT, ABS_X, ABS_Y and ABS_PRESSURE values.
- * Short tap send button touch event, little longer tap send button right event
- *   and longer tap send only coordinates.
+ *   ABS_X, ABS_Y, BTN_TOUCH and ABS_PRESSURE values.
  * Tested only with Kodi application.
  *
  * code based on
@@ -79,8 +77,6 @@ char *uinput_names[] = {"/dev/uinput", "/dev/input/uinput", "/dev/misc/uinput"};
 #define UINPUT_NAMES_NUM ((int) (sizeof(uinput_names)/sizeof(char *)))
 
 __u32 xres = 0, yres = 0;
-struct timeval tv_short_tap = {0, 300};  /* sec, msec, short tap sends BTN_TOUCH */
-struct timeval tv_right_tap = {1, 0};    /* sec, msec, longer tap sends BTN_RIGHT */
 bool calibration_mode = false;
 int sock = -1;
 
@@ -164,15 +160,15 @@ static int send_event(int fd, __u16 type, __u16 code, __s32 value)
 }
 
 static void signal_handler(int signal_number) {
-	if (signal_number == SIGHUP) {
-  	/* reload modules (and calibration data) */
-  	printf("signal handler %d, reconfig ts\n", signal_number);
-  	if (ts_reconfig(ts)) {
-  	  die("ts_reconfig")
-	  }
-	  
-	  return;
-	} else if (signal_number == SIGUSR1)
+  if (signal_number == SIGHUP) {
+    /* reload modules (and calibration data) */
+    printf("signal handler %d, reconfig ts\n", signal_number);
+    if (ts_reconfig(ts)) {
+      die("ts_reconfig")
+    }
+
+    return;
+  } else if (signal_number == SIGUSR1)
     calibration_mode = true;
   else if (signal_number == SIGUSR2)
     calibration_mode = false;
@@ -403,20 +399,20 @@ int get_resolution(void)
   return 0;
 
 not_found:
-	env_str = getenv("TSLIB_RES_X");
-	if (env_str != NULL)
-	  xres = atoi(env_str);
-
-	env_str = getenv("TSLIB_RES_Y");
-	if (env_str != NULL)
-	  yres = atoi(env_str);
-	
-	if (xres == 0 || yres == 0) {
-		xres = yres = 0;
-		return -1;
-	}
-	
-	return 0;
+  env_str = getenv("TSLIB_RES_X");
+  if (env_str != NULL)
+    xres = atoi(env_str);
+
+  env_str = getenv("TSLIB_RES_Y");
+  if (env_str != NULL)
+    yres = atoi(env_str);
+
+  if (xres == 0 || yres == 0) {
+    xres = yres = 0;
+    return -1;
+  }
+
+  return 0;
 }
 
 int main(int argc, char *argv[])
@@ -428,43 +424,18 @@ int main(int argc, char *argv[])
   int uinput_fd;
   struct uinput_user_dev uidev;
   int daemon = 0;
-  struct timeval tv_last;
-  struct timeval tv_sub;
   char *touch_str;
   int val;
   struct sigaction sa;
   struct sockaddr_un remote_addr;
 
-  touch_str = getenv("TSLIB_TAP_TIME");
-  if (touch_str != NULL) {
-    val = atoi(touch_str);
-    if (val < 1000) {
-      tv_short_tap.tv_sec = 0;
-      tv_short_tap.tv_usec = val;
-    } else {
-      tv_short_tap.tv_sec = val / 1000;
-      tv_short_tap.tv_usec = val % 1000;
-    }
-  }
-
   ret = get_resolution();
 
-  while ((c = getopt(argc, argv, "?dt:x:y:")) != -1) {
+  while ((c = getopt(argc, argv, "?dx:y:")) != -1) {
     switch (c) {
       case 'd':
         daemon = 1;
         break;
-      case 't':
-        val = atoi(optarg);
-        if (val < 1000) {
-          tv_short_tap.tv_sec = 0;
-          tv_short_tap.tv_usec = val;
-        } else {
-          tv_short_tap.tv_sec = val / 1000;
-          tv_short_tap.tv_usec = val % 1000;
-        }
-
-        break;
       case 'x':
         xres = atoi(optarg);
         break;
@@ -516,16 +487,6 @@ int main(int argc, char *argv[])
   if (uinput_fd < 0)
     die("error: opening uinput")
 
-  if (tv_short_tap.tv_sec == 0)
-    printf("Short tap time: %li msec\n", tv_short_tap.tv_usec);
-  else
-    printf("Short tap time: %li.%li sec\n", tv_short_tap.tv_sec, tv_short_tap.tv_usec);
-
-  if (tv_right_tap.tv_sec == 0)
-    printf("Right tap time: %li msec\n", tv_right_tap.tv_usec);
-  else
-    printf("Right tap time: %li.%li sec\n", tv_right_tap.tv_sec, tv_right_tap.tv_usec);
-
   memset (&sa, 0, sizeof (sa));
   sa.sa_handler = &signal_handler;
   sigaction(SIGHUP, &sa, NULL);
@@ -540,7 +501,6 @@ int main(int argc, char *argv[])
   set_ioctl(uinput_fd, UI_SET_EVBIT,  EV_SYN);
   set_ioctl(uinput_fd, UI_SET_EVBIT,  EV_KEY);
   set_ioctl(uinput_fd, UI_SET_KEYBIT, BTN_TOUCH);
-  set_ioctl(uinput_fd, UI_SET_KEYBIT, BTN_RIGHT);
   set_ioctl(uinput_fd, UI_SET_EVBIT,  EV_ABS);
   set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_X);
   set_ioctl(uinput_fd, UI_SET_ABSBIT, ABS_Y);
@@ -564,12 +524,7 @@ int main(int argc, char *argv[])
   if (ioctl(uinput_fd, UI_DEV_CREATE) < 0)
     die("error: ioctl UI_DEV_CREATE")
 
-  tv_short_tap.tv_usec *= 1000;   /* msec to usec */
-  tv_right_tap.tv_usec *= 1000;   /* msec to usec */
-
-  timerclear(&tv_last);
   while (1) {
-    touch_str = "";
     if (calibration_mode) {
       usleep(250000);   /* app become ready */
       printf("calibration mode started\n");
@@ -614,44 +569,18 @@ int main(int argc, char *argv[])
     } else if (ret != 1)
       continue;
 
-    send_event(uinput_fd, EV_ABS, ABS_X, samp.x);
-    send_event(uinput_fd, EV_ABS, ABS_Y, samp.y);
-
-    if (samp.pressure > 0) {  /* touched */
+    if (samp.pressure > 0) {
+      touch_str = "touched";
+      send_event(uinput_fd, EV_ABS, ABS_X, samp.x);
+      send_event(uinput_fd, EV_ABS, ABS_Y, samp.y);
       send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 255);
+      send_event(uinput_fd, EV_KEY, BTN_TOUCH, 1);
+      send_event(uinput_fd, EV_SYN, 0, 0);
+    } else {
+      touch_str = "released";
+      send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
+      send_event(uinput_fd, EV_KEY, BTN_TOUCH, 0);
       send_event(uinput_fd, EV_SYN, 0, 0);
-
-      if (timerisset(&tv_last) == false) {
-        memcpy(&tv_last, &samp.tv, sizeof(struct timeval)); /* touched first time */
-        touch_str = "touched first";
-      }
-    } else {  /* released */
-      timersub(&samp.tv, &tv_last, &tv_sub);
-      if (timercmp(&tv_sub, &tv_short_tap, <=)) {
-        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 255);
-        send_event(uinput_fd, EV_KEY, BTN_TOUCH, 1);
-        send_event(uinput_fd, EV_SYN, 0, 0);
-        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
-        send_event(uinput_fd, EV_KEY, BTN_TOUCH, 0);
-        send_event(uinput_fd, EV_SYN, 0, 0);
-
-        touch_str = "released and send tap";
-      } else if (timercmp(&tv_sub, &tv_right_tap, <=)) {
-        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 255);
-        send_event(uinput_fd, EV_KEY, BTN_RIGHT, 1);
-        send_event(uinput_fd, EV_SYN, 0, 0);
-        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
-        send_event(uinput_fd, EV_KEY, BTN_RIGHT, 0);
-        send_event(uinput_fd, EV_SYN, 0, 0);
-
-        touch_str = "released and send right";
-      } else {
-        send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
-        send_event(uinput_fd, EV_SYN, 0, 0);
-        touch_str = "released";
-      }
-
-      timerclear(&tv_last);
     }
 
     printf("%ld.%06ld: %6d %6d %6d  %s\n", samp.tv.tv_sec, samp.tv.tv_usec,

From a5f00518cfe38002c47895424eda26746711a0da Mon Sep 17 00:00:00 2001
From: Peter Vicman <peter.vicman@gmail.com>
Date: Tue, 24 Nov 2015 13:28:51 +0100
Subject: [PATCH 11/11] ts_uinput_touch: move cursor out of display after
 touched

---
 tests/ts_uinput_touch.c | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/tests/ts_uinput_touch.c b/tests/ts_uinput_touch.c
index 92db9ce..8280b18 100644
--- a/tests/ts_uinput_touch.c
+++ b/tests/ts_uinput_touch.c
@@ -415,6 +415,22 @@ int get_resolution(void)
   return 0;
 }
 
+int get_touch_home_time(void)
+{
+  char *env_str;
+  int touch_home_time = 0;
+
+  env_str = getenv("TSLIB_TOUCH_HOME_TIME");
+  if (env_str != NULL) {
+    touch_home_time = atoi(env_str);
+    if (touch_home_time < 0 || touch_home_time > 5000)
+      touch_home_time = 100;  /*  100 msec */
+  }
+
+  touch_home_time *= 1000;  /* msec to usec */
+  return touch_home_time;
+}
+
 int main(int argc, char *argv[])
 {
   int c;
@@ -424,11 +440,25 @@ int main(int argc, char *argv[])
   int uinput_fd;
   struct uinput_user_dev uidev;
   int daemon = 0;
+  int touch_home_time = 0;
   char *touch_str;
   int val;
   struct sigaction sa;
   struct sockaddr_un remote_addr;
 
+  printf("\nts_uinput_touch environment variables:\n");
+  printf("       TSLIB_TSDEVICE: '%s'\n", getenv("TSLIB_TSDEVICE"));
+  printf("      TSLIB_PLUGINDIR: '%s'\n", getenv("TSLIB_PLUGINDIR"));
+  printf("  TSLIB_CONSOLEDEVICE: '%s'\n", getenv("TSLIB_CONSOLEDEVICE"));
+  printf("       TSLIB_FBDEVICE: '%s'\n", getenv("TSLIB_FBDEVICE"));
+  printf("      TSLIB_CALIBFILE: '%s'\n", getenv("TSLIB_CALIBFILE"));
+  printf("       TSLIB_CONFFILE: '%s'\n", getenv("TSLIB_CONFFILE"));
+  printf("          TSLIB_RES_X: '%s'\n", getenv("TSLIB_RES_X"));
+  printf("          TSLIB_RES_Y: '%s'\n", getenv("TSLIB_RES_Y"));
+  printf("TSLIB_TOUCH_HOME_TIME: '%s'\n", getenv("TSLIB_TOUCH_HOME_TIME"));
+  printf("\n");
+
+  touch_home_time = get_touch_home_time();
   ret = get_resolution();
 
   while ((c = getopt(argc, argv, "?dx:y:")) != -1) {
@@ -581,6 +611,13 @@ int main(int argc, char *argv[])
       send_event(uinput_fd, EV_ABS, ABS_PRESSURE, 0);
       send_event(uinput_fd, EV_KEY, BTN_TOUCH, 0);
       send_event(uinput_fd, EV_SYN, 0, 0);
+
+      if (touch_home_time > 0) {
+        usleep(touch_home_time);   /* short delay for kodi */
+        send_event(uinput_fd, EV_ABS, ABS_X, -50);  /* hide cursor */
+        send_event(uinput_fd, EV_ABS, ABS_Y, -50);
+        send_event(uinput_fd, EV_SYN, 0, 0);
+      }
     }
 
     printf("%ld.%06ld: %6d %6d %6d  %s\n", samp.tv.tv_sec, samp.tv.tv_usec,
